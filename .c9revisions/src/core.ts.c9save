{"ts":1374102648648,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1374102872937,"patch":[[{"diffs":[[1,"/// <reference path='typings/typescriptServices.d.ts' />\n/// <reference path='typings/codemirror.d.ts' />\n\nmodule teapo.core {\n\n    class DocScript {\n        version = 1;\n        contentLength = 0;\n        \n        private _editRanges: { length: number; textChangeRange: TypeScript.TextChangeRange; }[] = [];\n        private _earlyChange: { from: number; to: number; } = null;\n\n        constructor(public path: string, public doc: CodeMirror.Doc) {\n            CodeMirror.on(this.doc, 'beforeChange', (doc, change) => this._docBeforeChanged(change));\n            CodeMirror.on(this.doc, 'change', (doc, change) => this._docChanged(change));\n        }\n\n        createSnapshot() {\n            return new DocScriptSnapshot(this.doc, this, this.version);\n        }\n    \n        getTextChangeRangeBetweenVersions(startVersion:number, endVersion: number) {\n            if (startVersion === endVersion)\n                return TypeScript.TextChangeRange.unchanged;\n    \n            var initialEditRangeIndex = this._editRanges.length - (this.version - startVersion);\n            var lastEditRangeIndex = this._editRanges.length - (this.version - endVersion);\n    \n            var entries = this._editRanges.slice(initialEditRangeIndex, lastEditRangeIndex);\n            return TypeScript.TextChangeRange.collapseChangesAcrossMultipleVersions(entries.map(e => e.textChangeRange));\n        }\n    \n        private _docBeforeChanged(change: CodeMirror.EditorChange) {\n            var from = this.doc.indexFromPos(change.from);\n            var to = this.doc.indexFromPos(change.to);\n            \n            this._earlyChange = { from: from, to: to };\n        }\n    \n        private _docChanged(change: CodeMirror.EditorChange) {\n            if (!this._earlyChange)\n                return;\n    \n            var newFromPosition = change.from;\n            var newToPosition = !change.text || change.text.length === 0 ? change.from : {\n                line: change.from.line + change.text.length,\n                ch: (change.to.line == change.from.line ? change.from.ch : 0) + change.text[change.text.length - 1].length\n            };\n    \n            var newLength = this.doc.indexFromPos(newToPosition) - this.doc.indexFromPos(newFromPosition);\n    \n            if ('console' in window) {\n                console.log(\n                    '_editContent('+\n                        this._earlyChange.from+', '+\n                        this._earlyChange.to+', '+\n                        (newLength - (this._earlyChange.to - this._earlyChange.from))+\n                    ') /*'+change.text+'*/');\n            }\n                \n            this._editContent(this._earlyChange.from, this._earlyChange.to, newLength);\n    \n            this._earlyChange = null;\n        }\n    \n        private _editContent(start: number, end: number, newLength: number) {\n            this.contentLength += end - start + newLength;\n            \n            var newSpan = TypeScript.TextSpan.fromBounds(start, end);\n            \n            // Store edit range + new length of script\n            var textChangeRange = new TypeScript.TextChangeRange(\n                newSpan,\n                newLength);\n    \n            this._editRanges.push({\n                length: this.contentLength,\n                textChangeRange: textChangeRange\n            });\n    \n            // Update version #\n            this.version++;\n        }\n    }\n    \n    class DocScriptSnapshot implements TypeScript.IScriptSnapshot {\n        constructor(\n            private _doc: CodeMirror.Doc,\n            private _script: {\n                getTextChangeRangeBetweenVersions(scriptVersion: number, version: number): TypeScript.TextChangeRange;\n            },\n            private _version: number) {\n        }\n        \n        getText(start: number, end: number): string {\n            var startPos = this._doc.posFromIndex(start);\n            var endPos = this._doc.posFromIndex(end);\n            var text = this._doc.getRange(startPos, endPos);\n            return text;\n        }\n    \n    \tgetLength(): number {\n    \t\treturn this._doc.getValue().length;\n    \t}\n    \n    \tgetLineStartPositions(): number[]{\n    \t\tvar result: number[] = [];\n    \t\tvar pos: CodeMirror.Pos = {\n    \t\t\tline: 0,\n    \t\t\tch: 0\n    \t\t};\n    \n    \t\tthis._doc.eachLine((line) => {\n    \t\t\tpos.line = result.length;\n    \t\t\tvar lineStartPosition = this._doc.indexFromPos(pos);\n    \t\t\tresult.push(lineStartPosition);\n    \t\t} );\n    \t\treturn result;\n    \t}\n    \n    \tgetTextChangeRangeSinceVersion(scriptVersion: number): TypeScript.TextChangeRange {\n    \t\tvar range = this._script.getTextChangeRangeBetweenVersions(scriptVersion, this._version);\n    \t\treturn range;\n    \t}\n    }\n\n    class LanguageServiceHost implements Services.ILanguageServiceHost {\n        compilationSettings = new TypeScript.CompilationSettings();\n        logOutput: { text: string; level: string; }[] = [];\n\n        private _diagnostics: Services.ILanguageServicesDiagnostics = null;\n        private _lastLogFlagRequest: string = null;\n        \n        constructor(private _fileSystem: TSFileSystem) {\n        }\n\n        // ILanguageServiceHost\n        \n        getScriptByteOrderMark(fileName: string): ByteOrderMark {\n            return ByteOrderMark.None;\n        }\n\n        getCompilationSettings(): TypeScript.CompilationSettings { return this.compilationSettings; }\n\n        getScriptFileNames(): string[] {\n            var result: string[] = [];\n            for (var k in this._fileSystem.scripts) if (this._fileSystem.scripts.hasOwnProperty(k)) {\n                var file = this._fileSystem.scripts[k];\n                if (file)\n                    result.push(file.path);\n            }\n            return result;\n        }\n\n        getScriptVersion(fileName: string): number {\n            var script = this._fileSystem.scripts[fileName];\n            if (!(script instanceof DocScript))\n                throw new Error('File not found.');\n\n            return script.version;\n        }\n\n        getScriptIsOpen(fileName: string): boolean {\n            // TODO: figure out whatever that flag means\n            return false;\n        }\n\n        getScriptSnapshot(fileName: string): TypeScript.IScriptSnapshot {\n            var script = this._fileSystem.scripts[fileName];\n            if (!(script instanceof DocScript))\n                throw new Error('File not found.');\n\n            return script.createSnapshot();\n        }\n\n        getDiagnosticsObject(): Services.ILanguageServicesDiagnostics {\n            if (!this._diagnostics)\n                this._diagnostics = { log: (content: string) => this._diagnosticsLog(content) };\n            return this._diagnostics;\n        }\n\n        // ILogger\n\n        information(): boolean {\n            this._lastLogFlagRequest = 'information';\n            return this._fileSystem.logLevels.information;\n        }\n\n        debug(): boolean {\n            this._lastLogFlagRequest = 'debug';\n            return this._fileSystem.logLevels.debug;\n        }\n\n        warning(): boolean {\n            this._lastLogFlagRequest = 'warning';\n            return this._fileSystem.logLevels.warning;\n        }\n\n        error(): boolean {\n            this._lastLogFlagRequest = 'error';\n            return this._fileSystem.logLevels.error;\n        }\n\n        fatal(): boolean {\n            this._lastLogFlagRequest = 'fatal';\n            return this._fileSystem.logLevels.fatal;\n        }\n\n        log(s: string): void {\n            this.logOutput.push({\n                text: s,\n                level: this._lastLogFlagRequest\n            });\n        }\n\n        // IReferenceResolveHost\n\n        // implemented above as part of ILanguageHost\n        // getScriptSnapshot(fileName: string): TypeScript.IScriptSnapshot\n\n        resolveRelativePath(path: string, directory: string): string {\n            if (!path)\n                return directory;\n            if (!directory)\n                return path;\n\n            // TODO: find out whether that's the right direction, also whether .. needs to be parsed\n            if (directory.charAt(0)=='/')\n                return path + directory;\n            else\n                return path + '/' + directory;\n        }\n\n        fileExists(path: string): boolean {\n            var allScriptsNames = this._fileSystem.scriptNames();\n            for (var i = 0; i < allScriptsNames.length; i++) {\n                if (allScriptsNames[i]===path)\n                    return true;\n            }\n            return false;\n        }\n\n        directoryExists(path: string): boolean {\n            var pattern = path;\n            if (pattern.charAt(0)!=='/')\n                pattern = '/'+pattern;\n            if (pattern.charAt(pattern.length-1)!=='/')\n                pattern = pattern+'/';\n\n            // we only store files, no directories\n            // -- so we need to look for files starting with '/directory/'\n            var allScriptsNames = this._fileSystem.scriptNames();\n            for (var i = 0; i < allScriptsNames.length; i++) {\n                var fn = allScriptsNames[i];\n                if (fn.length<pattern.length)\n                    continue;\n                if (fn.substring(0,pattern.length)===pattern)\n                    return true;\n            }\n            return false;\n        }\n\n        getParentDirectory(path: string): string {\n            var lastSlash = path.lastIndexOf('/');\n            if (lastSlash===path.length-1)\n                lastSlash = path.lastIndexOf('/', lastSlash-1);\n            if (lastSlash <= 0)\n                return '/';\n            else\n                return path.substr(0, lastSlash);\n        }\n\n        \n        private _diagnosticsLog(s: string): void {\n            this.logOutput.push({\n                text: s,\n                level: 'diagnostics'\n            });\n        }\n    }\n\n\tclass TSFileSystem {\n        private _host: LanguageServiceHost;\n\n    \ttypescript: Services.ILanguageService;\n\n        scripts: { [filename: string]: DocScript; } = {};\n        logLevels = {\n            information: true,\n            debug: true,\n            warning: true,\n            error: true,\n            fatal: true\n        };\n\n\t\tconstructor() {\n            this._host = new LanguageServiceHost(this);\n            var factory = new Services.TypeScriptServicesFactory();\n            this.typescript = factory.createPullLanguageService(this._host);\n\t\t}\n\n        createScript(filename: string, content: string): DocScript {\n            if (!filename\n                || typeof filename !== 'string'\n                || filename.charAt(0) !== '/')\n                throw new Error('Absolute filename starting with back slash expected.');\n\n            if (this.scripts[filename])\n                throw new Error('File already exists.');\n\n            var doc = new CodeMirror.Doc(content);\n            var script = new DocScript(filename, doc);\n\n            this.scripts[filename] = script;\n\n            return script;\n        }\n\n        scriptNames(): string[] {\n            var result: string[] = [];\n            for (var k in this.scripts) if (this.scripts.hasOwnProperty(k)) {\n                var s = this.scripts[k];\n                if (s instanceof DocScript)\n                    result.push(s.path);\n            }\n            return result;\n        }\n    }\n    \n    export class FileSystem {\n        private _fs: TSFileSystem;\n        typescript: Services.ILanguageService;\n\n        onchange: () => void = null;\n\n        constructor() {\n            this._fs = new TSFileSystem();\n            this.typescript = this._fs.typescript;\n        }\n\n        createScript(filename: string, content: string): CodeMirror.Doc {\n            var script = this._fs.createScript(filename, content);\n\n            CodeMirror.on(script.doc, 'change', <any>(() =>\n                {\n                    this.onchange();\n                }));\n\n            return script.doc;\n        }\n\n        scriptNames(): string[] {\n            return this._fs.scriptNames();\n        }\n\n        getScript(filename: string): CodeMirror.Doc {\n            var script = this._fs.scripts[filename];\n            if (script instanceof DocScript)\n                return script.doc;\n            else\n                throw new Error('File not found.');\n        }\n    }\n}"]],"start1":0,"start2":0,"length1":0,"length2":12224}]],"length":12224,"saved":false}
